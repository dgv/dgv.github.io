<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on Morten Linderud</title>
    <link>http://localhost:1313/tags/linux/</link>
    <description>Recent content in Linux on Morten Linderud</description>
    <generator>Hugo</generator>
    <language>nb</language>
    <lastBuildDate>Fri, 18 Apr 2025 14:00:00 +0200</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Easter hack: terraform-provider-openwrt</title>
      <link>http://localhost:1313/blog/easter-hack-terraform-provider-openwrt/</link>
      <pubDate>Fri, 18 Apr 2025 14:00:00 +0200</pubDate>
      <guid>http://localhost:1313/blog/easter-hack-terraform-provider-openwrt/</guid>
      <description>&lt;p&gt;April is usualy tax season for most people in Norway, and as I got some &lt;a href=&#34;https://www.youtube.com/watch?v=ThRXs74EjeE&#34;&gt;&amp;ldquo;money&#xA;back on the sk√¶tt&amp;rdquo;&lt;/a&gt; I wound up purchasing an &lt;a href=&#34;https://openwrt.org/toh/openwrt/one&#34;&gt;OpenWrt One&lt;/a&gt; to replace my 13-14 year old Asus router. I&amp;rsquo;ve been meaning to learn a bit more&#xA;about networking in general and getting an OpenWrt router seemed like a fun&#xA;project.&lt;/p&gt;&#xA;&lt;p&gt;Last year I bought a &lt;a href=&#34;https://www.gl-inet.com/products/gl-mt3000/&#34;&gt;Beryl AX&lt;/a&gt; from GL-Inet as I was travelling for a few&#xA;weeks. It&amp;rsquo;s a qute smol travel router that runs a fork of OpenWrt. But during&#xA;a recent conference it was reset and I realized I did not have a backup of any&#xA;configuration files for the device. Oops!&lt;/p&gt;</description>
    </item>
    <item>
      <title>NixOS is not reproducible</title>
      <link>http://localhost:1313/blog/nixos-is-not-reproducible/</link>
      <pubDate>Tue, 02 Apr 2024 19:21:08 +0200</pubDate>
      <guid>http://localhost:1313/blog/nixos-is-not-reproducible/</guid>
      <description>&lt;p&gt;Okay, sorry for the clickbait.&lt;/p&gt;&#xA;&lt;p&gt;NixOS is not reproducible according to the Reproducible Builds definition.&lt;/p&gt;&#xA;&lt;p&gt;I keep reading people making this claim repeatedly on orange-site, even&#xA;LWN.net made a similar claim when writing about Nix and Guix earlier this&#xA;week.&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; Along with their recently launched &lt;a href=&#34;https://wiki.nixos.org/wiki/Overview_of_the_NixOS_Linux_distribution&#34;&gt;wiki&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;So, what is the Reproducible Builds definition?&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;When is a build reproducible?&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;A build is reproducible if given the same source code, build environment and&#xA;build instructions, any party can recreate bit-by-bit identical copies of all&#xA;specified artifacts.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Stream to chromecast with resolved, vlc and bash</title>
      <link>http://localhost:1313/blog/stream-to-chromecast-with-resolved-vlc-and-bash/</link>
      <pubDate>Sat, 06 Jan 2024 20:59:20 +0200</pubDate>
      <guid>http://localhost:1313/blog/stream-to-chromecast-with-resolved-vlc-and-bash/</guid>
      <description>&lt;p&gt;Chromecast is one of those devices I just generally use a lot. They are small&#xA;practical and enables me to stream video or music to my TV from multiple&#xA;devices. But it also requires you to have a supported browser or video player.&#xA;This is obviously a bit boring.&lt;/p&gt;&#xA;&lt;p&gt;There has been multiple command line chromecast streamers through the years. But&#xA;their ffmpeg usage has been shoddy at best with no hardware decoding support and&#xA;usually quite bad implementations.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang crypto/ecdh and the TPM</title>
      <link>http://localhost:1313/blog/golang-crypto/ecdh-and-the-tpm/</link>
      <pubDate>Mon, 24 Apr 2023 20:00:00 +0200</pubDate>
      <guid>http://localhost:1313/blog/golang-crypto/ecdh-and-the-tpm/</guid>
      <description>&lt;p&gt;I have lately been trying to learn more about the Trusted Platform Module (TPM)&#xA;as they are capable of key creation and sealing secrets in a secure manner. They&#xA;are common hardware these days and make for a reasonable ways to store secrets.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/FiloSottile/age&#34;&gt;&lt;code&gt;age&lt;/code&gt;&lt;/a&gt; is a file encryption/decryption tool&#xA;from Filippo Valsorda which a lot of people have been using to replace GnuPG for&#xA;things like &lt;code&gt;password-store&lt;/code&gt;. It has a few plugins doing things like storing&#xA;keys on Yubikey, Trezor hardware wallets or the Apple Secure Enclave, however&#xA;it doesn&amp;rsquo;t have a TPM plugin. I saw the opportunity to write something that is&#xA;capable of utilizing the TPM.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Monitoring the kernel.org Transparency Log for a year</title>
      <link>http://localhost:1313/blog/monitoring-the-kernel.org-transparency-log-for-a-year/</link>
      <pubDate>Sat, 16 Apr 2022 00:00:00 +0200</pubDate>
      <guid>http://localhost:1313/blog/monitoring-the-kernel.org-transparency-log-for-a-year/</guid>
      <description>&lt;p&gt;Lets prefix this with: I really love Transparency Logs!&lt;/p&gt;&#xA;&lt;p&gt;It&amp;rsquo;s a fairly simple concept: If you hash elements together in a binary tree,&#xA;you can validate and verify if elements are present on a tree by hashing a&#xA;couple of elements. This is what is commonly known as a &lt;a href=&#34;https://en.wikipedia.org/wiki/Merkle_tree&#34;&gt;Merkle tree&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;I forget the math, but if you have a tree with a million items, you would only&#xA;really need less than 10 hashes (I think) to figure out what the hash of the top&#xA;node would be. This allows you to easily audit and verify the tree is internally&#xA;consistent. If you compare this to something like git, which people often&#xA;mistake for a Merkle tree, you would need to effectively replay a million&#xA;commits to figure out if the last commit hash is actually correct or not.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
