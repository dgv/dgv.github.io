<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Transparency Log on Morten Linderud</title>
    <link>http://localhost:1313/tags/transparency-log/</link>
    <description>Recent content in Transparency Log on Morten Linderud</description>
    <generator>Hugo</generator>
    <language>nb</language>
    <lastBuildDate>Sat, 16 Apr 2022 00:00:00 +0200</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/transparency-log/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Monitoring the kernel.org Transparency Log for a year</title>
      <link>http://localhost:1313/blog/monitoring-the-kernel.org-transparency-log-for-a-year/</link>
      <pubDate>Sat, 16 Apr 2022 00:00:00 +0200</pubDate>
      <guid>http://localhost:1313/blog/monitoring-the-kernel.org-transparency-log-for-a-year/</guid>
      <description>&lt;p&gt;Lets prefix this with: I really love Transparency Logs!&lt;/p&gt;&#xA;&lt;p&gt;It&amp;rsquo;s a fairly simple concept: If you hash elements together in a binary tree,&#xA;you can validate and verify if elements are present on a tree by hashing a&#xA;couple of elements. This is what is commonly known as a &lt;a href=&#34;https://en.wikipedia.org/wiki/Merkle_tree&#34;&gt;Merkle tree&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;I forget the math, but if you have a tree with a million items, you would only&#xA;really need less than 10 hashes (I think) to figure out what the hash of the top&#xA;node would be. This allows you to easily audit and verify the tree is internally&#xA;consistent. If you compare this to something like git, which people often&#xA;mistake for a Merkle tree, you would need to effectively replay a million&#xA;commits to figure out if the last commit hash is actually correct or not.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
